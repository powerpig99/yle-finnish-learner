/**
 * YouTube Platform - Injected Script
 *
 * This script runs in the page context (not extension context) to intercept
 * YouTube's timedtext/caption API responses.
 *
 * Supports any source language (default: English) with option to switch.
 * Only active on /watch pages.
 */

(function() {
  'use strict';

  console.info('DualSubExtension: YouTube injected script loaded');

  // Store for caption tracks discovered
  let captionTracks = [];
  let currentVideoId = null;
  // Default to English, can be changed via settings
  let sourceLanguage = 'en';

  /**
   * Check if we're on a YouTube watch page
   * @returns {boolean}
   */
  function isWatchPage() {
    return window.location.pathname === '/watch';
  }

  /**
   * Check if a URL matches the current source language
   * @param {string} url - The timedtext URL
   * @returns {boolean}
   */
  function matchesSourceLanguage(url) {
    const urlLower = url.toLowerCase();
    const langPattern = `lang=${sourceLanguage}`;
    return urlLower.includes(langPattern);
  }

  /**
   * Extract language code from timedtext URL
   * @param {string} url
   * @returns {string|null}
   */
  function extractLanguageFromUrl(url) {
    const match = url.match(/[?&]lang=([a-z]{2,3})/i);
    return match ? match[1].toLowerCase() : null;
  }

  /**
   * Parse YouTube's JSON3 caption format
   * @param {Object} json3Data - The JSON3 caption response
   * @returns {Array<{text: string, startTime: number, endTime: number}>}
   */
  function parseYouTubeJSON3Captions(json3Data) {
    const subtitles = [];

    if (!json3Data || !json3Data.events) {
      return subtitles;
    }

    for (const event of json3Data.events) {
      if (!event.segs) continue;

      const text = event.segs
        .map(seg => seg.utf8 || '')
        .join('')
        .trim();

      if (text.length === 0) continue;

      const startTime = (event.tStartMs || 0) / 1000;
      const duration = (event.dDurationMs || 0) / 1000;

      subtitles.push({
        text,
        startTime,
        endTime: startTime + duration
      });
    }

    return subtitles;
  }

  /**
   * Parse YouTube's srv3 (XML) caption format
   * @param {string} xmlText
   * @returns {Array}
   */
  function parseYouTubeSrv3Captions(xmlText) {
    const subtitles = [];

    try {
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
      const textElements = xmlDoc.querySelectorAll('text');

      for (const el of textElements) {
        const text = (el.textContent || '').trim();
        if (text.length === 0) continue;

        const start = parseFloat(el.getAttribute('start') || '0');
        const dur = parseFloat(el.getAttribute('dur') || '0');

        subtitles.push({
          text: decodeHTMLEntities(text),
          startTime: start,
          endTime: start + dur
        });
      }
    } catch (e) {
      console.error('DualSubExtension: Error parsing srv3 captions:', e);
    }

    return subtitles;
  }

  /**
   * Decode HTML entities
   * @param {string} text
   * @returns {string}
   */
  function decodeHTMLEntities(text) {
    const textarea = document.createElement('textarea');
    textarea.innerHTML = text;
    return textarea.value;
  }

  /**
   * Extract caption tracks from player response
   * @param {Object} playerResponse
   */
  function extractCaptionTracks(playerResponse) {
    if (!isWatchPage()) return;

    try {
      const captions = playerResponse?.captions?.playerCaptionsTracklistRenderer;
      if (!captions || !captions.captionTracks) return;

      captionTracks = captions.captionTracks.map(track => ({
        languageCode: track.languageCode,
        name: track.name?.simpleText || track.languageCode,
        baseUrl: track.baseUrl,
        isAutoGenerated: track.kind === 'asr',
        vssId: track.vssId
      }));

      console.info('DualSubExtension: Found caption tracks:',
        captionTracks.map(t => `${t.languageCode}${t.isAutoGenerated ? ' (auto)' : ''}`).join(', '));

      // Dispatch event with available tracks
      document.dispatchEvent(new CustomEvent('youtubeCaptionTracksAvailable', {
        bubbles: true,
        detail: {
          tracks: captionTracks,
          videoId: currentVideoId
        }
      }));

      // Proactively fetch subtitles for the source language
      fetchSubtitlesForLanguage(sourceLanguage);

    } catch (e) {
      console.error('DualSubExtension: Error extracting caption tracks:', e);
    }
  }

  /**
   * Fetch subtitles for a specific language from the discovered tracks
   * @param {string} lang - Language code to fetch
   */
  async function fetchSubtitlesForLanguage(lang) {
    // Find a matching track (prefer non-auto, but accept auto)
    let track = captionTracks.find(t => t.languageCode === lang && !t.isAutoGenerated);
    if (!track) {
      track = captionTracks.find(t => t.languageCode === lang);
    }
    // If no exact match, try the first available track
    if (!track && captionTracks.length > 0) {
      track = captionTracks.find(t => !t.isAutoGenerated) || captionTracks[0];
      console.info(`DualSubExtension: No ${lang} track found, using ${track.languageCode}`);
    }

    if (!track || !track.baseUrl) {
      console.warn('DualSubExtension: No caption track available to fetch');
      return;
    }

    try {
      // Use the baseUrl directly first, then try with json3 format
      let url = track.baseUrl;

      // Proactive fetch often fails (requires YouTube's auth context)
      // This is expected - we rely on intercepting YouTube's own requests
      const response = await originalFetch(url);

      if (!response.ok) {
        // Silent fail - interception will work when YouTube loads captions
        return;
      }

      const text = await response.text();

      // Check if response is valid
      if (!text || text.startsWith('<!DOCTYPE') || text.startsWith('<html')) {
        // Silent fail - got HTML instead of subtitle data
        return;
      }

      let subtitles = [];

      // Try to parse based on content
      if (text.trim().startsWith('{')) {
        // JSON format
        const data = JSON.parse(text);
        subtitles = parseYouTubeJSON3Captions(data);
      } else if (text.trim().startsWith('<')) {
        // XML format
        subtitles = parseYouTubeSrv3Captions(text);
      }

      if (subtitles.length > 0) {
        document.dispatchEvent(new CustomEvent('youtubeSubtitlesLoaded', {
          bubbles: true,
          detail: {
            subtitles,
            language: track.languageCode,
            url
          }
        }));
        console.info(`DualSubExtension: Fetched ${subtitles.length} ${track.languageCode.toUpperCase()} subtitles`);
      }
      // Silent fail if no subtitles parsed - interception will handle it
    } catch (e) {
      // Silent fail - proactive fetch errors are expected
    }
  }

  /**
   * Get video ID from URL
   * @returns {string|null}
   */
  function getVideoIdFromUrl() {
    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get('v');
  }

  /**
   * Process timedtext response and dispatch event
   * @param {string} url
   * @param {string|Object} data
   * @param {string} contentType
   */
  function processTimedtextResponse(url, data, contentType) {
    if (!isWatchPage()) return;

    const lang = extractLanguageFromUrl(url);
    if (!lang) return;

    let subtitles = [];

    try {
      if (typeof data === 'object') {
        subtitles = parseYouTubeJSON3Captions(data);
      } else if (typeof data === 'string') {
        if (data.trim().startsWith('{')) {
          subtitles = parseYouTubeJSON3Captions(JSON.parse(data));
        } else if (data.trim().startsWith('<')) {
          subtitles = parseYouTubeSrv3Captions(data);
        }
      }
    } catch (e) {
      console.error('DualSubExtension: Error parsing captions:', e);
      return;
    }

    if (subtitles.length > 0) {
      document.dispatchEvent(new CustomEvent('youtubeSubtitlesLoaded', {
        bubbles: true,
        detail: {
          subtitles,
          language: lang,
          url
        }
      }));
      console.info(`DualSubExtension: Loaded ${subtitles.length} ${lang.toUpperCase()} subtitles`);
    }
  }

  // Intercept fetch API
  const originalFetch = window.fetch;
  window.fetch = async function(input, init) {
    const response = await originalFetch.apply(this, arguments);

    if (!isWatchPage()) return response;

    let url = typeof input === 'string' ? input : input.url;

    // Log any timedtext or subtitle-related requests
    if (url.includes('timedtext') || url.includes('caption') || url.includes('subtitle')) {
      console.info('DualSubExtension: Intercepted fetch request:', url.substring(0, 100));
    }

    if (url.includes('/api/timedtext') || url.includes('timedtext?')) {
      console.info('DualSubExtension: Processing timedtext fetch response');
      try {
        const clonedResponse = response.clone();
        const contentType = clonedResponse.headers.get('content-type') || '';

        if (contentType.includes('application/json') || url.includes('fmt=json3')) {
          const json = await clonedResponse.json();
          processTimedtextResponse(url, json, contentType);
        } else {
          const text = await clonedResponse.text();
          processTimedtextResponse(url, text, contentType);
        }
      } catch (e) {
        console.error('DualSubExtension: Error processing fetch response:', e);
      }
    }

    return response;
  };

  // Intercept XMLHttpRequest
  const XHR = XMLHttpRequest.prototype;
  const originalOpen = XHR.open;
  const originalSend = XHR.send;

  XHR.open = function(method, url) {
    this._url = url;
    return originalOpen.apply(this, arguments);
  };

  XHR.send = function(data) {
    this.addEventListener('load', function() {
      if (!isWatchPage()) return;

      const url = this._url || '';

      // Log any timedtext or subtitle-related requests
      if (url.includes('timedtext') || url.includes('caption') || url.includes('subtitle')) {
        console.info('DualSubExtension: Intercepted XHR request:', url.substring(0, 100));
      }

      if (url.includes('/api/timedtext') || url.includes('timedtext?')) {
        console.info('DualSubExtension: Processing timedtext XHR response');
        const contentType = this.getResponseHeader('content-type') || '';
        processTimedtextResponse(url, this.responseText, contentType);
      }
    });

    return originalSend.apply(this, arguments);
  };

  // Hook JSON.parse to catch player response
  const originalJSONParse = JSON.parse;
  JSON.parse = function(text) {
    const result = originalJSONParse.apply(this, arguments);

    if (!isWatchPage()) return result;

    if (result?.captions?.playerCaptionsTracklistRenderer) {
      const newVideoId = getVideoIdFromUrl();
      if (newVideoId !== currentVideoId) {
        currentVideoId = newVideoId;
        captionTracks = [];
      }
      extractCaptionTracks(result);
    }

    return result;
  };

  // Check for initial player response
  function checkInitialPlayerResponse() {
    if (!isWatchPage()) return;

    if (window.ytInitialPlayerResponse) {
      currentVideoId = getVideoIdFromUrl();
      extractCaptionTracks(window.ytInitialPlayerResponse);
    }
  }

  // Initial check
  if (isWatchPage()) {
    setTimeout(checkInitialPlayerResponse, 1000);
  }

  // Handle SPA navigation
  let lastUrl = location.href;
  new MutationObserver(() => {
    if (location.href !== lastUrl) {
      lastUrl = location.href;
      captionTracks = [];
      currentVideoId = getVideoIdFromUrl();

      if (isWatchPage()) {
        setTimeout(checkInitialPlayerResponse, 500);
      }
    }
  }).observe(document.body, { childList: true, subtree: true });

  // Listen for source language change from content script
  document.addEventListener('setYouTubeSourceLanguage', (e) => {
    sourceLanguage = e.detail.language || 'en';
    console.info('DualSubExtension: Source language set to', sourceLanguage);
    // Fetch subtitles for the new language
    if (captionTracks.length > 0) {
      fetchSubtitlesForLanguage(sourceLanguage);
    }
  });

})();
